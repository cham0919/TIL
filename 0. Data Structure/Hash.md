#해시함수(hash function)

데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수. <br/>
이 때 매핑 전 원래 데이터의 값을 **키(key)**, 매핑 후 데이터의 값을 **해시값(hash value)**, 매핑하는 과정 자체를 **해싱(hashing)**이라고 칭한다. <br/>
해시함수는 해쉬값의 개수보다 대개 많은 키값을 해쉬값으로 변환(many-to-one 대응)하기 때문에 해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 해시충돌(collision)이 발생하게 된다.


### 장점

적은 리소스로 많은 데이터를 효율적으로 관리하기 위함. 무한에 가까운 데이터(키)들을 유한한 개수의 해시값으로 매핑함으로써 작은 크기의 캐쉬 메모리로도 프로세스를 관리할 수 있게 되기 때문이다. <br/>
데이터 액세스(삽입, 삭제, 탐색)시 계산복잡성을 O(1)을 지향한다.

#해시테이블(hash table)

해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 **색인(index) 혹은 주소** 삼아 데이터의 값(value)을 키와 함께 저장하는 자료구조를 칭한다.
이 때 데이터가 저장되는 곳을 **버킷(bucket)**이라고 한다.

ex)
![image](https://user-images.githubusercontent.com/61372486/122212956-63ab4980-cee3-11eb-89fa-baf90a464cb2.png)


### Direct-address table

키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 말한다 <br/>

##### 장점

키 개수와 해시테이블 크기가 동일하기 때문에 해시충돌 문제가 발생하지 않는다


##### 단점

전체 키가 실제 사용하는 키보다 훨씬 많은 경우 사용하지 않는 키들을 위한 공간까지 마련해야 하는 탓에 메모리 효율성이 크게 떨어진다


# 해시 충돌 피하는 기법

## 1. Entry 사용
 
버킷 안의 엔트리 저장하는 방법을 통해 해시 충볼이 발생했을 때의 문제 완화

### 1.1 chaining

한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않는 방법. <br/>
해당 버킷에 이미 데이터가 존재한다면, 체인처럼 노드를 추가하여 연결한다. <br/>
유연하게 관리할 수 있지만 메모리 문제가 발생할 가능성이 존재한다.


### 1.2 open addressing

한 버킷당 들어갈 수 있는 엔트리가 하나뿐이지만 해시함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장할 수 있도록 허용하는 방법

#### 탐사(probing)

#####선형 탐사(Linear probing)

최초 해시값에 해당하는 버킷에 다른 데이터가 저장돼 있으면 해당 해시값에서 고정 폭을 옮겨 다음 해시값에 해당하는 버킷에 접근(삽입, 삭제, 탐색)한다. <br/>
하지만 주변 버킷이 모두 채워져 있는 상태에 취약하다.

#####제곱 탐사(Quadratic probing)

선형 탐사처럼 고정 폭을 옮기는 것이 아닌 그 폭이 제곱수로 늘어가는 방법. <br/>
ex) 1<sup>2</sup>칸 이동 -> 2<sup>2</sup>칸 이동 -> 3<sup>2</sup>칸 이동 <br/>
초기 해시값이 같으면 다음 탐사 위치 또한 동일하기 때문에 효율성이 떨어진다

#####이중 해싱(double hashing)

탐사할 해시값의 규칙성을 없애버린 기법/ <br/>
2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을 때, 또 다른 하나는 해시충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용 <br/>
탐사 이동폭이 달라지고, 탐사 이동폭이 같더라도 최초 해시값이 달라져 선형, 제곱 탐사에 대한 문제 완화 가능


## 2. 해시함수 사용

해시함수를 사용해 해시 충볼이 발생했을 때의 문제 완화



### 2.1 division method

숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 반환. <br/>
m은, 대개 소수(prime number)를 쓰며 특히 2의 제곱수와 거리가 먼 소수를 사용하는 것이 좋다고 함 <br/>
해시함수 특성 때문에 해시테이블 크기가 정해진다는 단점이 존재


### 2.2 multiplication method

숫자로 된 키가 k이고 A는 0과 1 사이의 실수일 때 <br/> 
***h(k) = (kA mod 1) × m*** <br/>
나눗셈법보다는 다소 느림


### 2.3 universal hasing

다수의 해시함수를 만들고, 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법 <br/>
H 에서 무작위로 뽑은 해시함수가 주어졌을 때 임의의 키값을 임의의 해시값에 매핑할 확률을 1/m로 만드려는 것이 목적 <br/>
