## 정렬


<br/>

### 정렬의 두가지 중요한 사용법
 - 탐색에서 보조로 사용
 - 리스트의 엔트리를 비교하는 방법으로 사용
 - 최적화, 그래프 이론, 잡 스케줄링 등
 
<br/>

### 정렬 방법
 - 내부 방법
    - 정렬할 리스트가 작아 전체적인 정렬이 메인 메모리 상에서 실행될 수 있을 때 사용
 - 외부 방법
    - 큰 리스트에 사용
 

<br/><br/>


## 여러 키에 의한 정렬

- K<sup>1</sup>,K<sup>2</sup>,,,K<sup>t</sup>(K<sup>1</sup>은 최대 유효키, K<sup>t</sup>는 최소 유효키)의 여러개의 키를 갖는 레코드의 정렬
  - 모든 레코드 쌍 i, j에 대하여 
    - i < j, (K<sub>i</sub><sup>1</sup>,,,K<sub>i</sub><sup>t</sup>) <= (K<sub>j</sub><sup>1</sup>,,,K<sub>j</sub><sup>t</sup>) 이 성립하면 레코드 R<sub>1</sub>...R<sub>n</sub>의 리스트는 키 K<sub>1</sub>...K<sub>t</sub>
  
<br/>

- 카드 뭉치를 정렬하는 문제
  - 두 개의 키 (무늬, 숫자)에 대한 정렬 문제
    - K<sup>1</sup>[무늬] : ♣ < ◆ < ♥ < ♠
    - K<sup>2</sup>[숫자] : 2 < 3 < 4 <...< 10 < J < Q < K < A
  - 정렬된 카드 뭉치 -> 2♣,,,,A♣,,,,,,2♠,,,,,A♠


<br/>


#### MSD(most-significant-digit-first) 정렬

- 최대 유효 숫자 우선 정렬
  - 먼저 최대 유효 키 K<sup>1</sup>로 정렬 -> K<sup>1</sup>에 대해 같은 값을 가지는 여러 레코드 파일들이 만들어짐
  - 각 파일에 대해 독립적으로 K<sup>2</sup>로 정렬 -> K<sup>1</sup>, K<sup>2</sup>에 대해 같은 값을 가지는 서브 파일들이 만들어짐
  - 각 서브파일에 대해서는 K<sup>3</sup>으로 정렬
  - 최종적으로 이렇게 얻어진 파일들을 합친다
  
  
<br/>


#### LSD(least-significant-digit-first) 정렬

- 최소 유효 숫자 우선 정렬
  - 카드 숫자 값(키 K<sup>2</sup>)에 따라 13개 파일 만듦
  - 3들을 2들 위에, king들을 queen들 위에, ace들을 king들 위에 올려놓음
- 카드 뭉치를 뒤집어 놓고 안정된 정렬 방법을 이용하여 무늬(K<sup>1</sup>)에 따라 4개의 파일로 만듦
- 4개의 파일들은 키 K<sup>2</sup>에 따라 정렬되게 합침

<br/>

 - LSD가 MSD보다 더 단순
   - 생성된 파일과 서브 파일을 독립적으로 정렬할 필요가 없으므로 오버헤드가 적게 든다
   
<br/>


#### 기수(radix) 정렬

 - 어떤 기수 r을 이용하여 정렬 키를 몇 개의 숫자로 분해
    - r=10 : 키를 십진수로 분할
    - r=2 : 키를 이진수로 분할
 - 기수-r 정렬에서는 r개의 빈(bin)이 필요
    - 정렬되어야 하는 레코드가 R<sub>1</sub>,,,R<sub>n</sub>일 때, 레코드의 키는 기수-r을 이용하여 분할 -> 0~(r-1) 사이의 d자리 키가 된다
    - 각 빈의 레코드는 빈의 첫 레코드를 가리키는 포인터와 마지막 레코드를 가리키는 포인터를 통해 체인으로 연결되며, 체인은 큐처럼 동작

<br/>

ex)
**범위가 [0,999]인 십진수를 정렬 (d-3, r=10)**
 
![](https://images.velog.io/images/cham/post/80cc5062-9a2c-4ccc-9c9e-35aa09074d71/image.png)
![](https://images.velog.io/images/cham/post/3f07d95d-e2bd-4840-a2f3-03cd8346b2b5/image.png)
![](https://images.velog.io/images/cham/post/5543f185-7ab9-425d-acf6-75801758b97f/image.png)
   
   
<br/>

## 내부 정렬 요약

#### 내부 정렬 비교

 - 삽입 정렬 : 리스트가 부분적으로 정렬되어 있을 때 좋음. 작은 n에 대해 가장 좋은 정렬 방법
 - 합병 정렬 : 최악의 경우에 가장 좋은 방법. 히프 정렬에 비해 더 많은 공간을 필요로 함
 - 퀵 정렬 : 평균 성능이 가장 좋음 / 최악의 경우 : O(n<sup>2</sup>)
 - 기수 정렬 : 성능이 키의 크기와 r의 선택에 영향을 받음
 
 ![](https://images.velog.io/images/cham/post/6a217548-61c6-4d78-804c-739368dc5acc/image.png)
 
 
<br/><br/><br/><br/>
   
---
참조
- 고려대학교 김상곤 교수님 강의 중


