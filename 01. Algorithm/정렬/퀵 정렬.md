# 퀵 정렬

- 평균 성능이 가장 좋은 정렬 방법

<br/>

## 퀵 정렬 단계

  1) 정렬할 레코드 중 피벗(pivot) 레코드를 선택
  2) 정렬할 레코드들을 다시 정돈
    - 피벗의 왼쪽 : 피벗의 키보다 작거나 같은 레코드들을 위치
    - 피벗의 오른쪽 : 피벗의 키보다 크거나 같은 레코드들을 위치
  3) 퀵 정렬을 순환적으로 사용
    - 피벗의 왼쪽과 오른쪽의 레코드들은 서로 독립적으로 정렬


<br/>

ex)
**키 (26, 5, 37, 1, 61, 11, 59, 15, 48, 19)를 가진 10개의 레코드로 된 리스트를 퀵 정렬 사용하여 정렬**

![](https://images.velog.io/images/cham/post/f32e8b2f-9d05-43f7-9ef1-18a3b4f58d83/image.png)

- quickSort를 호출할 때마다의 리스트 상태
- 대괄호는 계속해서 정렬할 서브리스트를 나타냄


<br/>

## quickSort 분석

  - 최악의 경우 복잡도 : O(n<sup>2</sup>)

<br/> 
 
- 한 레코드의 위치가 정확히 정해질 때마다 그 레코드의 왼쪽과 오른쪽의 서브리스트 크기가 같을 경우
  - 크기가 n/2인 두 개의 서브리스트를 정렬하는 작업과 동일
  - 크기가 n인 리스트에서 한 레코드를 위치시키는데 필요한 시간 : O(n)
  
<br/> 

- 평균 연산 시간 : O(nlogn)
  
  
<br/>

## 구현

```java
public class Main {

    public static void main(String[] args) {

        int[] data = {26, 5, 37, 1, 61, 11, 59, 15, 48, 19};

        sort(data, 0, data.length - 1);
        System.out.println(Arrays.toString(data));
    }

    public static void sort(int[] data, int l, int r){
        int left = l;
        int right = r;
        int pivot = data[(l+r)/2];

        do{
            while(data[left] < pivot) left++;
            while(data[right] > pivot) right--;
            if(left <= right){
                int temp = data[left];
                data[left] = data[right];
                data[right] = temp;
                left++;
                right--;
            }
        }while (left <= right);

        if(l < right) sort(data, l, right);
        if(r > left) sort(data, left, r);
    }
}
```


 
<br/><br/><br/><br/>
   
---
참조
- 고려대학교 김상곤 교수님 강의 중
- [Algorithm | Sort : 퀵 정렬](https://gongbu-ing.tistory.com/66)